Having retrieved the deleted version of the malware that allows Tracy McGreedy to control elves remotely, Forensic McBlue and his team have started investigating to stop the mind control incident. They are now planning to take revenge by analysing the C2's back-end infrastructure based on the malware's source code.

**Learning Objectives**

In this task, we will focus on the following vital learnings to assist Forensic McBlue in analysing the retrieved malware sample:

- The foundations of analysing malware samples safely
- The fundamentals of .NET binaries
- The dnSpy tool for decompiling malware samples written in .NET
- Building an essential methodology for analysing malware source code

**Malware Handling 101**

Forensic McBlue.WARNING: Handling a malware sample is dangerous. Always take precautions during your analysis. 

As mentioned, handling malware is dangerous because it is software explicitly designed to cause harm, steal information, or compromise the security and functionality of computer systems. Given this, we will again introduce the concept of malware sandboxing.

A sandbox is like a pretend computer setup that acts like a real one. It's a safe place for experts to test malware and see how it behaves without any danger. Having a sandbox environment is essential when conducting malware analysis because it stops experts from running malware on their actual work computers, which could be risky and harmful.

A typical environment setup of a malware sandbox contains the following:

- Network controls: Sandboxes often have network controls to limit and monitor the network traffic the malware generates. This also prevents the propagation of malware in any other assets.
- Virtualisation: Many sandboxes use technologies like VMware, VirtualBox, or Hyper-V to run the malware in a controlled, isolated environment. This allows for easy snapshots, resets, and disposal after the analysis.
- Monitoring and logging: Sandboxes record detailed logs of the malware's activities, including system interactions, network traffic, and file modification. These logs are invaluable for analysing and understanding the malware's behaviour.

**Introduction to .NET Compiled Binaries**

Van Sprinkles..NET binaries are compiled files containing code written in languages compatible with the .NET framework, such as C#, VB.NET, F#, or managed C++. These binaries are executable files (with the .exe extension) or dynamic link libraries (DLLs with the .dll extension). They can also be assemblies that contain multiple types and resources.

Compared to other programming languages like C or C++, languages that use .NET, such as C#, don't directly translate the code into machine code after compilation. Instead, they use an intermediate language (IL), like a pseudocode, and translate it into native machine code during runtime via a Common Language Runtime (CLR) environment.

This may be a bit overwhelming. In simple terms, it's only possible to analyse a C or C++ compiled binary by reading its assembly instructions (low-level). Meanwhile, a C# binary can be decompiled and its source code retrieved since the intermediate language contains metadata that can be reconverted to its source code form.

**Basic C# Programming**

Based on the elves' initial checks, it has been discovered that the retrieved malware is written in C#. So, let's quickly discuss C#'s code syntax to analyse the sample effectively.

1. Namespaces, classes, functions and variables

For this section, let's use this code snippet:

```
namespace DemoOnly
{
    internal class BasicProgramming
    {
        static void Main(string[] args)
        {
            string to_print = "Hello World!";
            ShowOutput(to_print);
        }

        public static void ShowOutput(string text)
        {
            // prints the contents of the text variable - or simply, this is a print function
            Console.WriteLine(text);
        }
    }
}
```

| Code Syntax | Details |
|---|---|
| Namespace | A container that organises related code elements, such as classes, into a logical grouping. It helps prevent naming conflicts and provides structure to the code. In this example, the namespace ```DemoOnly``` is the namespace that contains the ```BasicProgramming``` class. |
|Class  | Defines the structure and behaviour (through functions or methods) of the objects it contains. In this example, ```BasicProgramming``` is a class that includes the ```Main``` function and the ```ShowOutput``` function. Moreover, the ```Main``` function is the program's entry point, where the program starts its execution. |
| Function | A reusable block of code that performs a specific task or action. In this example, the ```ShowOutput``` function takes a string (through the ```text``` argument) as an input and uses it on ```Console.WriteLine``` to print it as its output. Note that the ```ShowOutput``` function only receives one argument based on how it is written.  |
| Variable | A named storage location that can hold data, such as numbers (integers), text (strings), or objects. In this example, ```to_print``` is a variable that handles the text: "Hello World!" |

2. For loops 

A for loop is a control structure used to repeatedly execute a block of code a specified number of times. It typically consists of three main components: initialisation, condition, and iteration. Let's use the example below:

```
 // for (initialisation; condition; iteration)
for (int i = 1; i <= 5; i++) {
    Console.WriteLine("I love McSkidy");
}
```

In this example, the loop is initialised with ```1``` and stored in the variable ```i``` (initialisation), checks if variable ```i``` is less than or equal to ```5``` (condition), and increments ```1``` to itself (adds ```1``` to itself) every loop (iteration). 

So, in simple terms, the code snippet means that it will call the Console.WriteLine function 5 times since the loop will count from 1 to 5.

Loops can be immediately terminated using the code break.

3. Conditional statements

Conditional statements, like ```if``` and ```else```, are control flow statements used for conditional code execution. They allow you to control which code block should be executed based on a specified condition.

```
if (number > 5)
{
    Console.WriteLine("The number is greater than 5");
}
else
{
    Console.WriteLine("The number is less than or equal to 5");
}
```

Based on the example above, the if statement checks whether the number variable contains a number greater than 5 and prints the string:  "The number is greater than 5". If that condition is not satisfied, it will go to the else statement, which prints: "The number is less than or equal to 5".

Essentially, it will go to the code block of the if statement if the number variable is 7, and it will go to the else code block if the number variable is set to 4.

4. Importing modules

C# uses the ```using``` directive to include namespaces and access classes and functions from external libraries.

```
using System;
// after importing, we can now use all the classes and functions available from the System namespace
```

The code snippet above loads an external namespace called ```System```. This means that this code can now use everything inside the System namespace.

Don't worry if you find these code snippets a little overwhelming. Once we start analysing the malware, the following sections will be much easier to understand.

**C2 Primer**

According to Forensic McBlue, the retrieved malware sample is presumed to be related to the organisation's remote mind control (over C2) incident. So, to build the right mindset in solving this case, let's look at the run-through below about malware with C2 capabilities.

C2, or command and control, refers to a centralised system or infrastructure that malicious actors use to remotely manage and control compromised devices or systems. It serves as a channel through which attackers issue commands to compromised entities, enabling them to carry out various activities, such as data theft, surveillance, or further malware propagation.

![c81bb5ebb13873c669576ab072c6f283](https://github.com/schoto/Advent-of-Cyber-2023/assets/69323411/4dd5479d-391b-48f1-8a4f-63bcba8ea911)

Seeing C2 traffic means that malware has already been executed inside the victim machine, as detailed in the diagram above. In terms of cyber kill chain stages, the attacker has successfully crafted and delivered the malware to the target and potentially moves laterally inside the network to achieve its objectives.

To expound further, malware with C2 capabilities typically exhibits the following behaviours:

1. HTTP requests: C2 servers often communicate with compromised assets using HTTP(s) requests. These requests can be used to send commands or receive data.
2. Command execution: This behaviour is the most common, allowing attackers to execute OS commands inside the machine.
3. Sleep or delay: To evade detection and maintain stealth, threat actors typically instruct the running malware to enter a sleep or delay for a specific period. During this time, the malware won't do anything; it will only connect back to the C2 server once the timer completes.

We will try to find these functionalities in the following section. 

**Decompiling Malware Samples With dnSpy**

Now that we've tackled the theoretical concepts to build our technical skills, let's start playing with fire (malware)!

Since we already assume that the malware sample is written in C#, we will use dnSpy to decompile the binary and review its source code.

dnSpy is an open-source .NET assembly (C#) debugger and editor. It is typically used for reverse engineering .NET applications and analysing their code and is primarily designed for examining and modifying .NET assemblies in a user-friendly, interactive way. It's also capable of modifying the retrieved source code (editing), setting breakpoints, or running through the code one step at a time (debugging).

Note: As mentioned above, we won't execute the malware, so the debugging functionality will not be discussed in the following sections.

To proceed, let's go to the virtual machine and start the dnSpy tool by double-clicking the shortcut on the desktop.

![dnspy](https://github.com/schoto/Advent-of-Cyber-2023/assets/69323411/0540f814-d618-4638-9f3e-b7764f653754)

Once the tool is open, we will load the malware sample by navigating to ```File > Open``` located on the upper-left side of the application.

![dnspy2](https://github.com/schoto/Advent-of-Cyber-2023/assets/69323411/7a4f35bf-d75d-4541-b6c0-6e79dca61d2e)

When you get the prompt, click the following to navigate to the malware's location: ```This PC > Desktop > artefacts```.

![thispc](https://github.com/schoto/Advent-of-Cyber-2023/assets/69323411/f98f5744-e8e5-49b8-884d-f0ee12be33b1)

Now that you are inside the malware sample folder, you first need to change the file type to "All Files" to see the defanged version of the binary. Next, double-click the malware sample to load it into the application.

![thispc2](https://github.com/schoto/Advent-of-Cyber-2023/assets/69323411/64a52b59-517d-4db7-91d7-cadf4f5ebbb3)

Once the malware sample is loaded, you'll have a view like the image below. The next step is to click the ```Main``` string, which will take you to the entry point of the application.

![main](https://github.com/schoto/Advent-of-Cyber-2023/assets/69323411/b638fc6b-7905-440c-bf61-1b93f9ec2001)



